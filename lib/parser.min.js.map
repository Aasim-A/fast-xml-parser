{"version":3,"sources":["webpack://parser/webpack/bootstrap","webpack://parser/./src/util.js","webpack://parser/./src/xmlstr2xmlnode.js","webpack://parser/./src/parser.js","webpack://parser/./src/node2json.js","webpack://parser/./src/xmlNode.js","webpack://parser/./src/nimndata.js","webpack://parser/./src/node2json_str.js","webpack://parser/./src/validator.js","webpack://parser/./src/json2xml.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","doesMatch","string","regex","match","exec","isExist","v","isEmptyObject","obj","keys","length","merge","target","a","len","getValue","buildOptions","options","defaultOptions","props","newOptions","undefined","doesNotMatch","getAllMatches","matches","allmatches","index","push","util","require","xmlNode","TagType","OPENING","CLOSING","SELF","CDATA","regx","Number","parseInt","window","parseFloat","attributeNamePrefix","attrNodeName","textNodeName","ignoreAttributes","ignoreNameSpace","allowBooleanAttributes","parseNodeValue","parseAttributeValue","arrayMode","trimValues","cdataTagName","cdataPositionChar","localeRange","tagValueProcessor","attrValueProcessor","processTagValue","val","trim","parseValue","parseTrueNumberOnly","checkForTagType","substr","resolveNameSpace","tagname","tags","split","prefix","charAt","shouldParse","parsed","isNaN","indexOf","String","attrsRegx","RegExp","buildAttributesMap","attrStr","replace","attrs","attrName","attrCollection","getTraversalObj","xmlData","xmlObj","currentNode","tagsRegx","tag","nextTag","tagType","parent","childNode","attrsMap","addChild","nodeToJson","xmlToNodeobj","x2xmlnode","parse","convertToJson","convertTonimn","convert2nimn","convertToJsonString","validate","j2xParser","parseToNimn","schema","node","jObj","child","this","Array","isArray","char","fromCharCode","chars","nilChar","missingChar","nilPremitive","missingPremitive","emptyChar","emptyValue","boundryChar","objStart","arrStart","arrayEnd","charsArr","_e","e_schema","hasValidData","hasData","str","itemSchema","arr_len","arr_i","processValue","isAppChar","ch","x2j","_cToJsonStr","level","stringval","indentBy","readPI","start","err","code","msg","readCommentAndCDATA","angleBracketsCount","tagFound","regxAttrName","regxTagName","closingTag","tagName","substring","validateTagName","result","readAttributeStr","isValid","validateAttributeString","otg","pop","JSON","stringify","doubleQuote","singleQuote","startChar","validAttrStrRegxp","attrNames","validateAttrName","format","supressEmptyNode","Parser","isAttribute","attrPrefixLen","isCDATA","replaceCDATAstr","replaceCDATAarr","indentate","tagEndChar","newLine","buildTextNode","buildEmptyTextNode","buildObjNode","buildEmptyObjNode","buildTextValNode","buildObjectNode","cdata","join","includes","repeat","startsWith","j2x","attr","arrLen","j","item","Ks","L"],"mappings":"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","file":"./lib/parser.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 2);\n","\"use strict\";\n\nconst getAllMatches = function(string, regex) {\n    const matches = [];\n    let match = regex.exec(string);\n    while (match) {\n        const allmatches = [];\n        const len = match.length;\n        for (let index = 0; index < len; index++) {\n            allmatches.push(match[index]);\n        }\n        matches.push(allmatches);\n        match = regex.exec(string);\n    }\n    return matches;\n};\n\nconst doesMatch = function(string, regex) {\n    const match = regex.exec(string);\n    return !(match === null || typeof match === \"undefined\");\n};\n\nconst doesNotMatch = function(string, regex) {\n    return !doesMatch(string, regex);\n};\n\nexports.isExist = function(v) {\n    return typeof v !== \"undefined\";\n};\n\nexports.isEmptyObject = function(obj) {\n    return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a) {\n    if (a) {\n        const keys = Object.keys(a); // will return an array of own properties\n        const len = keys.length; //don't make it inline\n        for (let i = 0; i < len; i++) {\n            target[keys[i]] = a[keys[i]];\n        }\n    }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n    if (exports.isExist(v)) {\n        return v;\n    } else {\n        return \"\";\n    }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options,defaultOptions,props) {\n    var newOptions = {};\n    if (!options) {\n        return defaultOptions; //if there are not options\n    }\n\n    for (let i = 0; i < props.length; i++) {\n        if ( options[props[i]] !== undefined) {\n            newOptions[props[i]] = options[props[i]];\n        }else{\n            newOptions[props[i]] = defaultOptions[props[i]];\n        }\n    }\n    return newOptions;\n};\n\nexports.doesMatch = doesMatch;\nexports.doesNotMatch = doesNotMatch;\nexports.getAllMatches = getAllMatches;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst xmlNode = require(\"./xmlNode\");\nconst TagType = {\"OPENING\": 1, \"CLOSING\": 2, \"SELF\": 3, \"CDATA\": 4};\nlet regx = \"<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))([^>]*)>|((\\\\/)(([\\\\w:\\\\-._]*:)?([\\\\w:\\\\-._]+))\\\\s*>))([^<]*)\";\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt\n }\n if (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat= window.parseFloat\n }\n\nconst defaultOptions = {\n    attributeNamePrefix:    \"@_\",\n    attrNodeName:           false,\n    textNodeName:           \"#text\",\n    ignoreAttributes:       true,\n    ignoreNameSpace:        false,\n    allowBooleanAttributes: false,         //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseNodeValue:         true,\n    parseAttributeValue:    false,\n    arrayMode:              false,\n    trimValues:             true,                                //Trim string values of tag and attributes\n    cdataTagName:           false,\n    cdataPositionChar:      \"\\\\c\",\n    localeRange:            \"\",\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n    //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\"attributeNamePrefix\", \"attrNodeName\", \"textNodeName\", \"ignoreAttributes\", \"ignoreNameSpace\", \"allowBooleanAttributes\", \"parseNodeValue\", \"parseAttributeValue\", \"arrayMode\", \"trimValues\", \"cdataTagName\", \"cdataPositionChar\", \"localeRange\", \"tagValueProcessor\", \"attrValueProcessor\", \"parseTrueNumberOnly\"];\nexports.props = props;\n\nconst getTraversalObj = function(xmlData, options) {\n    options = buildOptions(options,defaultOptions,props);\n    //xmlData = xmlData.replace(/\\r?\\n/g, \" \");//make it single line\n    xmlData = xmlData.replace(/<!--[\\s\\S]*?-->/g, \"\");//Remove  comments\n\n    const xmlObj = new xmlNode(\"!xml\");\n    let currentNode = xmlObj;\n\n    regx = regx.replace(/\\[\\\\w/g, \"[\" + options.localeRange + \"\\\\w\");\n    const tagsRegx = new RegExp(regx, \"g\");\n    let tag = tagsRegx.exec(xmlData);\n    let nextTag = tagsRegx.exec(xmlData);\n    while (tag) {\n        const tagType = checkForTagType(tag);\n\n        if (tagType === TagType.CLOSING) {\n            //add parsed data to parent node\n            if (currentNode.parent && tag[14]) {\n                currentNode.parent.val = util.getValue(currentNode.parent.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            currentNode = currentNode.parent;\n        } else if (tagType === TagType.CDATA) {\n            if (options.cdataTagName) {\n                //add cdata node\n                const childNode = new xmlNode(options.cdataTagName, currentNode, tag[3]);\n                childNode.attrsMap = buildAttributesMap(tag[8], options);\n                currentNode.addChild(childNode);\n                //for backtracking\n                currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n                //add rest value to parent node\n                if (tag[14]) {\n                    currentNode.val += processTagValue(tag[14], options);\n                }\n            } else {\n                currentNode.val = (currentNode.val || \"\") + (tag[3] || \"\") + processTagValue(tag[14], options);\n            }\n        } else if (tagType === TagType.SELF) {\n            if (currentNode && tag[14]) {\n                currentNode.val = util.getValue(currentNode.val) + \"\" + processTagValue(tag[14], options);\n            }\n\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, \"\");\n            if (tag[8] && tag[8].length > 0) {\n                tag[8] = tag[8].substr(0, tag[8].length - 1);\n            }\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n        } else {//TagType.OPENING\n            const childNode = new xmlNode(options.ignoreNameSpace ? tag[7] : tag[5], currentNode, processTagValue(tag[14], options));\n            childNode.attrsMap = buildAttributesMap(tag[8], options);\n            currentNode.addChild(childNode);\n            currentNode = childNode;\n        }\n\n        tag = nextTag;\n        nextTag = tagsRegx.exec(xmlData);\n    }\n\n    return xmlObj;\n};\n\nfunction processTagValue(val, options) {\n    if (val) {\n        if (options.trimValues) {\n            val = val.trim();\n        }\n        val = options.tagValueProcessor(val);\n        val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n    }\n\n    return val;\n}\n\nfunction checkForTagType(match) {\n    if (match[4] === \"]]>\") {\n        return TagType.CDATA;\n    } else if (match[10] === \"/\") {\n        return TagType.CLOSING;\n    } else if (typeof match[8] !== \"undefined\" && match[8].substr(match[8].length - 1) === \"/\") {\n        return TagType.SELF;\n    } else {\n        return TagType.OPENING;\n    }\n}\n\nfunction resolveNameSpace(tagname, options) {\n    if (options.ignoreNameSpace) {\n        const tags = tagname.split(\":\");\n        const prefix = tagname.charAt(0) === \"/\" ? \"/\" : \"\";\n        if (tags[0] === \"xmlns\") {\n            return \"\";\n        }\n        if (tags.length === 2) {\n            tagname = prefix + tags[1];\n        }\n    }\n    return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n    if (shouldParse && typeof val === \"string\") {\n        let parsed;\n        if (val.trim() === \"\" || isNaN(val)) {\n            parsed = val === \"true\" ? true : val === \"false\" ? false : val;\n        } else {\n            if(val.indexOf(\"0x\") !== -1){//support hexa decimal\n                parsed = Number.parseInt(val,16);\n            } else if (val.indexOf(\".\") !== -1) {\n                parsed = Number.parseFloat(val);\n            } else {\n                parsed = Number.parseInt(val, 10);\n            }\n            if(parseTrueNumberOnly){\n                parsed = String(parsed) === val ? parsed : val;\n                \n            }\n        }\n        return parsed;\n    } else {\n        if (util.isExist(val)) {\n            return val;\n        } else {\n            return \"\";\n        }\n    }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp(\"([^\\\\s=]+)\\\\s*(=\\\\s*(['\\\"])(.*?)\\\\3)?\", \"g\");\n\nfunction buildAttributesMap(attrStr, options) {\n    if (!options.ignoreAttributes && typeof attrStr === \"string\") {\n        attrStr = attrStr.replace(/\\r?\\n/g, \" \");\n        //attrStr = attrStr || attrStr.trim();\n\n        const matches = util.getAllMatches(attrStr, attrsRegx);\n        const len = matches.length; //don't make it inline\n        const attrs = {};\n        for (let i = 0; i < len; i++) {\n            const attrName = resolveNameSpace(matches[i][1], options);\n            if (attrName.length) {\n                if (matches[i][4] !== undefined) {\n                    if (options.trimValues) {\n                        matches[i][4] = matches[i][4].trim();\n                    }\n                    matches[i][4] = options.attrValueProcessor(matches[i][4]);\n                    attrs[options.attributeNamePrefix + attrName] = parseValue(matches[i][4], options.parseAttributeValue, options.parseTrueNumberOnly);\n                } else if (options.allowBooleanAttributes) {\n                    attrs[options.attributeNamePrefix + attrName] = true;\n                }\n\n            }\n        }\n        if (!Object.keys(attrs).length) {\n            return;\n        }\n        if (options.attrNodeName) {\n            const attrCollection = {};\n            attrCollection[options.attrNodeName] = attrs;\n            return attrCollection;\n        }\n        return attrs;\n    }\n}\n\nexports.getTraversalObj = getTraversalObj;\n","\"use strict\";\n\nconst nodeToJson = require(\"./node2json\");\nconst xmlToNodeobj = require(\"./xmlstr2xmlnode\");\nconst x2xmlnode = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nexports.parse = function(xmlData, options) {\n    options = buildOptions(options, x2xmlnode.defaultOptions, x2xmlnode.props);\n    return nodeToJson.convertToJson(xmlToNodeobj.getTraversalObj(xmlData, options), options);\n};\nexports.convertTonimn = require(\"../src/nimndata\").convert2nimn;\nexports.getTraversalObj = xmlToNodeobj.getTraversalObj;\nexports.convertToJson = nodeToJson.convertToJson;\nexports.convertToJsonString = require(\"./node2json_str\").convertToJsonString;\nexports.validate = require(\"./validator\").validate;\nexports.j2xParser = require(\"./json2xml\");\nexports.parseToNimn = function (xmlData,schema,options){\n    return exports.convertTonimn(exports.getTraversalObj(xmlData,options), schema, options);\n};\n","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst convertToJson =function(node, options) {\n    const jObj = {};\n\n    //when no child node or attr is present\n    if ((!node.child  ||  util.isEmptyObject(node.child)) && (!node.attrsMap || util.isEmptyObject(node.attrsMap))) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else { //otherwise create a textnode if node has some text\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj[options.textNodeName] = node.val;\n            }\n        }\n    }\n\n    util.merge(jObj, node.attrsMap);\n\n    const keys = Object.keys(node.child);\n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj[tagname] = [];\n            for (var tag in node.child[tagname]) {\n                jObj[tagname].push( convertToJson(node.child[tagname][tag], options) );\n            }\n        } else {\n            jObj[tagname] = convertToJson(node.child[tagname][0], options);\n        }\n    }\n    \n    //add value\n    return jObj;\n};\n\nexports.convertToJson = convertToJson;","\"use strict\";\n\nmodule.exports = function(tagname, parent, val) {\n    this.tagname = tagname;\n    this.parent = parent;\n    this.child = {};//child tags\n    this.attrsMap = {};//attributes map\n    this.val = val;//text only\n    this.addChild = function(child) {\n        if ( Array.isArray(this.child[child.tagname]) ){//already presents\n            this.child[child.tagname].push(child);\n        } else {\n            this.child[child.tagname] = [child];\n        }\n    };\n};\n","\"use strict\";\nconst char = function(a) {\n    return String.fromCharCode(a);\n};\n\nconst chars = {\n    nilChar : char(176),\n    missingChar : char(201),\n    nilPremitive : char(175),\n    missingPremitive : char(200),\n\n    emptyChar : char(178),\n    emptyValue:  char(177),//empty Premitive\n    \n    boundryChar : char(179),\n    \n    objStart: char(198),\n    arrStart: char(204),\n    arrayEnd: char(185),\n};\n\nconst charsArr = [\n    chars.nilChar,\n    chars.nilPremitive,\n    chars.missingChar,\n    chars.missingPremitive,\n    chars.boundryChar,\n    chars.emptyChar,\n    chars.emptyValue,\n    chars.arrayEnd,\n    chars.objStart,\n    chars.arrStart\n];\n\nconst _e = function(node, e_schema, options) {\n    if (typeof e_schema === \"string\") {//premitive\n        if (node && node[0] && node[0].val !== undefined) {\n            return getValue(node[0].val, e_schema);\n        } else {\n            return getValue(node, e_schema);\n        }\n    } else {\n        const hasValidData = hasData(node);\n        if (hasValidData === true) {\n            let str = \"\";\n            if (Array.isArray(e_schema)) {\n                //attributes can't be repeated. hence check in children tags only\n                str += chars.arrStart;\n                const itemSchema = e_schema[0];\n                //var itemSchemaType = itemSchema;\n                const arr_len = node.length;\n\n                if (typeof itemSchema === \"string\") {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = getValue(node[arr_i].val, itemSchema);\n                        str = processValue(str, r);\n                    }\n                } else {\n                    for (let arr_i = 0; arr_i < arr_len; arr_i++) {\n                        const r = _e(node[arr_i], itemSchema, options);\n                        str = processValue(str, r);\n                    }\n                }\n                str += chars.arrayEnd;//indicates that next item is not array item\n            } else {//object\n                str += chars.objStart;\n                const keys = Object.keys(e_schema);\n                if (Array.isArray(node)) {\n                    node = node[0];\n                }\n                for (let i in keys) {\n                    const key = keys[i];\n                    //a property defined in schema can be present either in attrsMap or children tags\n                    //options.textNodeName will not present in both maps, take it's value from val\n                    //options.attrNodeName will be present in attrsMap\n                    let r;\n                    if (!options.ignoreAttributes && node.attrsMap && node.attrsMap[key]) {\n                        r = _e(node.attrsMap[key], e_schema[key], options);\n                    } else if (key === options.textNodeName) {\n                        r = _e(node.val, e_schema[key], options);\n                    } else {\n                        r = _e(node.child[key], e_schema[key], options);\n                    }\n                    str = processValue(str, r);\n                }\n            }\n            return str;\n        } else {\n            return hasValidData;\n        }\n    }\n};\n\nconst getValue = function(a/*, type*/) {\n    switch (a) {\n        case undefined:\n            return chars.missingPremitive;\n        case null:\n            return chars.nilPremitive;\n        case \"\":\n            return chars.emptyValue;\n        default:\n            return a;\n    }\n};\n\nconst processValue = function(str, r) {\n    if (!isAppChar(r[0]) && !isAppChar(str[str.length - 1])) {\n        str += chars.boundryChar;\n    }\n    return str + r;\n};\n\nconst isAppChar = function(ch) {\n    return charsArr.indexOf(ch) !== -1;\n};\n\nfunction hasData(jObj) {\n    if (jObj === undefined) {\n        return chars.missingChar;\n    } else if (jObj === null) {\n        return chars.nilChar;\n    } else if (jObj.child && Object.keys(jObj.child).length === 0 && (!jObj.attrsMap || Object.keys(jObj.attrsMap).length === 0)) {\n        return chars.emptyChar;\n    } else {\n        return true;\n    }\n}\n\nconst x2j = require(\"./xmlstr2xmlnode\");\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst convert2nimn = function(node, e_schema, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n    return _e(node, e_schema, options);\n};\n\nexports.convert2nimn = convert2nimn;\n","\"use strict\";\n\nconst util = require(\"./util\");\nconst buildOptions = require(\"./util\").buildOptions;\nconst x2j = require(\"./xmlstr2xmlnode\");\n\n//TODO: do it later\nconst convertToJsonString = function(node, options) {\n    options = buildOptions(options,x2j.defaultOptions,x2j.props);\n\n    options.indentBy = options.indentBy || \"\";\n    return _cToJsonStr(node, options,0);\n}\n\nconst _cToJsonStr = function(node, options,level) {\n    let jObj = \"{\";\n\n    //traver through all the children\n    const keys = Object.keys(node.child);\n    \n    for (let index = 0; index < keys.length; index++) {\n        var tagname = keys[index];\n        if (node.child[tagname] && node.child[tagname].length > 1) {\n            jObj  += \"\\\"\" + tagname + \"\\\" : [ \";\n            for (var tag in node.child[tagname]) {\n                jObj += _cToJsonStr(node.child[tagname][tag], options) + \" , \";\n            }\n            jObj = jObj.substr(0,jObj.length-1) + \" ] \"; //remove extra comma in last\n        } else {\n            jObj += \"\\\"\" +tagname + \"\\\" : \" + _cToJsonStr(node.child[tagname][0], options) + \" ,\";\n        }\n    }\n    util.merge(jObj, node.attrsMap);\n    //add attrsMap as new children\n    if (util.isEmptyObject(jObj)) {\n        return util.isExist(node.val) ? node.val : \"\";\n    } else {\n        if (util.isExist(node.val)) {\n            if (!(typeof node.val === \"string\" && (node.val === \"\" || node.val === options.cdataPositionChar))) {\n                jObj += \"\\\"\" + options.textNodeName +\"\\\" : \" + stringval(node.val);\n            }\n        }\n    }\n    //add value\n    if(jObj[jObj.length-1] === \",\"){\n        jObj = jObj.substr(0,jObj.length-2);\n    }\n    return jObj + \"}\";\n};\n\nfunction stringval(v){\n    if(v === true || v === false || !isNaN(v)){\n        return v;\n    }else{\n        return \"\\\"\" + v + \"\\\"\";\n    }\n}\n\nfunction indentate(options, level) {\n    return options.indentBy.repeat(level);\n}\n\nexports.convertToJsonString = convertToJsonString;","\"use strict\";\n\nconst util = require(\"./util\");\n\nconst defaultOptions = {\n    allowBooleanAttributes: false,         //A tag can have attributes without any value\n    localeRange:  \"a-zA-Z\"\n};\n\nconst props = [\"allowBooleanAttributes\", \"localeRange\"];\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function(xmlData, options) {\n    options = util.buildOptions(options,defaultOptions,props);\n\n    //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n    //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n    //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n\n    const tags = [];\n    let tagFound = false;\n    if (xmlData[0] === \"\\ufeff\") {  // check for byte order mark (BOM)\n      xmlData = xmlData.substr(1);\n    }\n    const regxAttrName = new RegExp(\"^[_w][\\\\w\\\\-.:]*$\".replace(\"_w\", \"_\" + options.localeRange));\n    const regxTagName = new RegExp(\"^([w]|_)[\\\\w.\\\\-_:]*\".replace(\"([w\", \"([\" + options.localeRange));\n    for (let i = 0; i < xmlData.length; i++) {\n\n        if (xmlData[i] === \"<\") { //starting of tag\n            //read until you reach to '>' avoiding any '>' in attribute value\n\n            i++;\n            if (xmlData[i] === \"?\") {\n                i = readPI(xmlData, ++i);\n                if (i.err) {\n                    return i;\n                }\n            } else if (xmlData[i] === \"!\") {\n                i = readCommentAndCDATA(xmlData, i);\n                continue;\n            } else {\n                let closingTag = false;\n                if (xmlData[i] === \"/\") {//closing tag\n                    closingTag = true;\n                    i++;\n                }\n                //read tagname\n                let tagName = \"\";\n                for (; i < xmlData.length &&\n                       xmlData[i] !== \">\" &&\n                       xmlData[i] !== \" \" &&\n                       xmlData[i] !== \"\\t\"; i++) {\n\n                    tagName += xmlData[i];\n                }\n                tagName = tagName.trim();\n                //console.log(tagName);\n\n                if (tagName[tagName.length - 1] === \"/\") {//self closing tag without attributes\n                    tagName = tagName.substring(0, tagName.length - 1);\n                    continue;\n                }\n                if (!validateTagName(tagName, regxTagName)) {\n                    return {err: {code: \"InvalidTag\", msg: \"Tag \" + tagName + \" is an invalid name.\"}};\n                }\n\n                const result = readAttributeStr(xmlData, i);\n                if (result === false) {\n                    return {err: {code: \"InvalidAttr\", msg: \"Attributes for \" + tagName + \" have open quote\"}};\n                }\n                let attrStr = result.value;\n                i = result.index;\n\n                if (attrStr[attrStr.length - 1] === \"/\") {//self closing tag\n                    attrStr = attrStr.substring(0, attrStr.length - 1);\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid === true) {\n                        tagFound = true;\n                        //continue; //text may presents after self closing tag\n                    } else {\n                        return isValid;\n                    }\n                } else if (closingTag) {\n                    if (attrStr.trim().length > 0) {\n                        return {err: {code: \"InvalidTag\", msg: \"closing tag \" + tagName + \" can't have attributes or invalid starting.\"}};\n                    } else {\n                        const otg = tags.pop();\n                        if (tagName !== otg) {\n                            return {err: {code: \"InvalidTag\", msg: \"closing tag \" + otg + \" is expected inplace of \" + tagName + \".\"}};\n                        }\n                    }\n                } else {\n                    const isValid = validateAttributeString(attrStr, options, regxAttrName);\n                    if (isValid !== true) {\n                        return isValid;\n                    }\n                    tags.push(tagName);\n                    tagFound = true;\n                }\n\n                //skip tag text value\n                //It may include comments and CDATA value\n                for (i++; i < xmlData.length; i++) {\n                    if (xmlData[i] === \"<\") {\n                        if (xmlData[i + 1] === \"!\") {//comment or CADATA\n                            i++;\n                            i = readCommentAndCDATA(xmlData, i);\n                            continue;\n                        } else {\n                            break;\n                        }\n                    }\n                }//end of reading tag text value\n                if (xmlData[i] === \"<\") {\n                    i--;\n                }\n            }\n        } else {\n            if (xmlData[i] === \" \" || xmlData[i] === \"\\t\" || xmlData[i] === \"\\n\" || xmlData[i] === \"\\r\") {\n                continue;\n            }\n            return {err: {code: \"InvalidChar\", msg: \"char \" + xmlData[i] + \" is not expected .\"}};\n        }\n    }\n\n    if (!tagFound) {\n        return {err: {code: \"InvalidXml\", msg: \"Start tag expected.\"}};\n    } else if (tags.length > 0) {\n        return {err: {code: \"InvalidXml\", msg: \"Invalid \" + JSON.stringify(tags, null, 4).replace(/\\r?\\n/g, \"\") + \" found.\"}};\n    }\n\n    return true;\n};\n\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n    var start = i;\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] == \"?\" || xmlData[i] == \" \") {//tagname\n            var tagname = xmlData.substr(start, i - start);\n            if (i > 5 && tagname === \"xml\") {\n                return {err: {code: \"InvalidXml\", msg: \"XML declaration allowed only at the start of the document.\"}};\n            } else if (xmlData[i] == \"?\" && xmlData[i + 1] == \">\") {\n                //check if valid attribut string\n                i++;\n                break;\n            } else {\n                continue;\n            }\n        }\n    }\n    return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n    if (xmlData.length > i + 5 && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \"-\") {//comment\n        for (i += 3; i < xmlData.length; i++) {\n            if (xmlData[i] === \"-\" && xmlData[i + 1] === \"-\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    } else if (xmlData.length > i + 8 &&\n               xmlData[i + 1] === \"D\" &&\n               xmlData[i + 2] === \"O\" &&\n               xmlData[i + 3] === \"C\" &&\n               xmlData[i + 4] === \"T\" &&\n               xmlData[i + 5] === \"Y\" &&\n               xmlData[i + 6] === \"P\" &&\n               xmlData[i + 7] === \"E\") {\n        let angleBracketsCount = 1;\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"<\") {angleBracketsCount++;}\n            else if (xmlData[i] === \">\") {\n                angleBracketsCount--;\n                if (angleBracketsCount === 0) {\n                    break;\n                }\n            }\n        }\n    } else if (xmlData.length > i + 9 &&\n               xmlData[i + 1] === \"[\" &&\n               xmlData[i + 2] === \"C\" &&\n               xmlData[i + 3] === \"D\" &&\n               xmlData[i + 4] === \"A\" &&\n               xmlData[i + 5] === \"T\" &&\n               xmlData[i + 6] === \"A\" &&\n               xmlData[i + 7] === \"[\") {\n\n        for (i += 8; i < xmlData.length; i++) {\n            if (xmlData[i] === \"]\" && xmlData[i + 1] === \"]\" && xmlData[i + 2] === \">\") {\n                i += 2;\n                break;\n            }\n        }\n    }\n\n    return i;\n}\n\nvar doubleQuote = \"\\\"\";\nvar singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n    let attrStr = \"\";\n    let startChar = \"\";\n    for (; i < xmlData.length; i++) {\n        if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n            if (startChar === \"\") {\n                startChar = xmlData[i];\n            } else if (startChar !== xmlData[i]) {\n                //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n                continue;\n            } else {\n                startChar = \"\";\n            }\n        } else if (xmlData[i] === \">\") {\n            if (startChar === \"\") {\n                break;\n            }\n        }\n        attrStr += xmlData[i];\n    }\n    if (startChar !== \"\") {\n        return false;\n    }\n\n    return {value: attrStr, index: i};\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp(\"(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*(['\\\"])(([\\\\s\\\\S])*?)\\\\5)?\", \"g\");\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options, regxAttrName) {\n    //console.log(\"start:\"+attrStr+\":end\");\n\n    //if(attrStr.trim().length === 0) return true; //empty string\n\n    const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n    const attrNames = {};\n\n    for (let i = 0; i < matches.length; i++) {\n        //console.log(matches[i]);\n\n        if (matches[i][1].length === 0) {//nospace before attribute name: a=\"sd\"b=\"saf\"\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + matches[i][2] + \" has no space in starting.\"}};\n        } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {//independent attribute: ab\n            return {err: {code: \"InvalidAttr\", msg: \"boolean attribute \" + matches[i][2] + \" is not allowed.\"}};\n        }\n        /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n        const attrName = matches[i][2];\n        if (!validateAttrName(attrName, regxAttrName)) {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is an invalid name.\"}};\n        }\n        if (!attrNames.hasOwnProperty(attrName)) {//check for duplicate attribute.\n            attrNames[attrName] = 1;\n        } else {\n            return {err: {code: \"InvalidAttr\", msg: \"attribute \" + attrName + \" is repeated.\"}};\n        }\n    }\n\n    return true;\n\n}\n\n// const validAttrRegxp = /^[_a-zA-Z][\\w\\-.:]*$/;\n\nfunction validateAttrName(attrName, regxAttrName) {\n    // const validAttrRegxp = new RegExp(regxAttrName);\n    return util.doesMatch(attrName, regxAttrName);\n}\n\n//const startsWithXML = new RegExp(\"^[Xx][Mm][Ll]\");\n//  startsWith = /^([a-zA-Z]|_)[\\w.\\-_:]*/;\n\nfunction validateTagName(tagname, regxTagName) {\n    /*if(util.doesMatch(tagname,startsWithXML)) return false;\n    else*/\n    return !util.doesNotMatch(tagname, regxTagName);\n}\n","\"use strict\";\n//parse Empty Node as self closing node\nconst buildOptions = require(\"./util\").buildOptions;\n\nconst defaultOptions = {\n    attributeNamePrefix: \"@_\",\n    attrNodeName: false,\n    textNodeName: \"#text\",\n    ignoreAttributes: true,\n    cdataTagName: false,\n    cdataPositionChar: \"\\\\c\",\n    format: false,\n    indentBy: \"  \",\n    supressEmptyNode: false,\n    tagValueProcessor: function(a) {return a},\n    attrValueProcessor: function(a) {return a}\n};\n\nconst props = [\n    \"attributeNamePrefix\",\n    \"attrNodeName\",\n    \"textNodeName\",\n    \"ignoreAttributes\",\n    \"cdataTagName\",\n    \"cdataPositionChar\",\n    \"format\",\n    \"indentBy\",\n    \"supressEmptyNode\",\n    \"tagValueProcessor\",\n    \"attrValueProcessor\"\n]\n\nfunction Parser(options) {\n    this.options = buildOptions(options,defaultOptions,props);\n    if (this.options.ignoreAttributes || this.options.attrNodeName) {\n        this.isAttribute = function(/*a*/) { return false;};\n    } else {\n        this.attrPrefixLen = this.options.attributeNamePrefix.length;\n        this.isAttribute = isAttribute;\n    }\n    if (this.options.cdataTagName) {\n        this.isCDATA = isCDATA;\n    } else {\n        this.isCDATA = function(/*a*/) { return false;};\n    }\n    this.replaceCDATAstr = replaceCDATAstr;\n    this.replaceCDATAarr = replaceCDATAarr;\n\n    if (this.options.format) {\n        this.indentate = indentate;\n        this.tagEndChar = \">\\n\";\n        this.newLine = \"\\n\";\n    } else {\n        this.indentate = function() { return \"\";};\n        this.tagEndChar = \">\";\n        this.newLine = \"\";\n    }\n\n    if (this.options.supressEmptyNode) {\n        this.buildTextNode = buildEmptyTextNode;\n        this.buildObjNode = buildEmptyObjNode;\n    } else {\n        this.buildTextNode = buildTextValNode;\n        this.buildObjNode = buildObjectNode;\n    }\n\n    this.buildTextValNode = buildTextValNode;\n    this.buildObjectNode = buildObjectNode;\n\n}\n\nParser.prototype.parse = function(jObj) {\n    return this.j2x(jObj, 0).val;\n};\n\nParser.prototype.j2x = function(jObj, level) {\n    let attrStr = \"\";\n    let val = \"\";\n    const keys = Object.keys(jObj);\n    const len = keys.length;\n    for (let i = 0; i < len; i++) {\n        const key = keys[i];\n        if (typeof jObj[key] === \"undefined\") {\n            // supress undefined node\n        }else if (jObj[key] === null) {\n            val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n        }else if (typeof jObj[key] !== \"object\") {//premitive type\n            const attr = this.isAttribute(key);\n            if (attr) {\n                attrStr += \" \" + attr + \"=\\\"\" +  this.options.attrValueProcessor(\"\" + jObj[key]) + \"\\\"\";\n            } else if (this.isCDATA(key)) {\n                if (jObj[this.options.textNodeName]) {\n                    val += this.replaceCDATAstr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                    val += this.replaceCDATAstr(\"\", jObj[key]);\n                }\n            } else {//tag value\n                if (key === this.options.textNodeName) {\n                    if (jObj[this.options.cdataTagName]) {\n                        //value will added while processing cdata\n                    } else {\n                        val +=  this.options.tagValueProcessor(\"\" + jObj[key]);\n                    }\n                } else {\n                    val += this.buildTextNode(jObj[key], key, \"\", level);\n                }\n            }\n        } else if (Array.isArray(jObj[key])) {//repeated nodes\n            if (this.isCDATA(key)) {\n              val += this.indentate(level)\n                if (jObj[this.options.textNodeName]) {\n                  val += this.replaceCDATAarr(jObj[this.options.textNodeName], jObj[key]);\n                } else {\n                  val += this.replaceCDATAarr(\"\", jObj[key]);\n                }\n            } else {//nested nodes\n                const arrLen = jObj[key].length;\n                for (let j = 0; j < arrLen; j++) {\n                    const item = jObj[key][j];\n                    if (typeof item === \"undefined\") {\n                        // supress undefined node\n                    }else if(item === null){\n                        val += this.indentate(level) + \"<\" + key + \"/\" + this.tagEndChar;\n                    }else if (typeof item === \"object\") {\n                        const result = this.j2x(item, level + 1);\n                        val += this.buildObjNode(result.val, key, result.attrStr, level);\n                    } else {\n                        val += this.buildTextNode(item, key, \"\", level);\n                    }\n                }\n            }\n        } else {//nested node\n            if (this.options.attrNodeName && key === this.options.attrNodeName) {\n                const Ks = Object.keys(jObj[key]);\n                const L = Ks.length;\n                for (let j = 0; j < L; j++) {\n                    attrStr += \" \" + Ks[j] + \"=\\\"\" + this.options.attrValueProcessor(\"\" + jObj[key][Ks[j]]) + \"\\\"\";\n                }\n            } else {\n                const result = this.j2x(jObj[key], level + 1);\n                val += this.buildObjNode(result.val, key, result.attrStr, level);\n            }\n        }\n    }\n    return {attrStr: attrStr, val: val};\n};\n\nfunction replaceCDATAstr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar;\n    } else {\n        return str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata + \"]]\" + this.tagEndChar);\n    }\n}\n\nfunction replaceCDATAarr(str, cdata) {\n    str = this.options.tagValueProcessor(\"\" + str);\n    if (this.options.cdataPositionChar === \"\" || str === \"\") {\n        return str + \"<![CDATA[\" + cdata.join(\"]]><![CDATA[\") + \"]]\" + this.tagEndChar;\n    } else {\n        for (let v in cdata) {\n            str = str.replace(this.options.cdataPositionChar, \"<![CDATA[\" + cdata[v] + \"]]>\");\n        }\n        return str + this.newLine;\n    }\n}\n\nfunction buildObjectNode(val, key, attrStr, level) {\n  if (attrStr && !val.includes('<')) {\n    return this.indentate(level)\n          + \"<\" + key + attrStr\n          + \">\"\n          + val\n          //+ this.newLine\n          // + this.indentate(level)\n          + \"</\" + key + this.tagEndChar;\n  } else {\n    return this.indentate(level)\n          + \"<\" + key + attrStr\n          + this.tagEndChar\n          + val\n          //+ this.newLine\n          + this.indentate(level)\n          + \"</\" + key + this.tagEndChar;\n  }\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildObjectNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level)\n               + \"<\" + key + attrStr\n               + \"/\"\n               + this.tagEndChar;\n        //+ this.newLine\n    }\n}\n\nfunction buildTextValNode(val, key, attrStr, level) {\n    return this.indentate(level) + \"<\" + key + attrStr + \">\" + this.options.tagValueProcessor(\"\" + val) + \"</\" + key + this.tagEndChar;\n}\n\nfunction buildEmptyTextNode(val, key, attrStr, level) {\n    if (val !== \"\") {\n        return this.buildTextValNode(val, key, attrStr, level);\n    } else {\n        return this.indentate(level) + \"<\" + key + attrStr + \"/\" + this.tagEndChar;\n    }\n}\n\nfunction indentate(level) {\n    return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name/*, options*/) {\n    if (name.startsWith(this.options.attributeNamePrefix)) {\n        return name.substr(this.attrPrefixLen);\n    } else {\n        return false;\n    }\n}\n\nfunction isCDATA(name) {\n    return name === this.options.cdataTagName;\n}\n\n//formatting\n//indentation\n//\\n after each closing or self closing tag\n\nmodule.exports = Parser;\n"],"sourceRoot":""}